---
title: "Create dose-response curves for DNT False Negatives"
output: 
  html_document:
    toc: true
    toc_float: true
    df_print: tibble
    code_folding: hide
date: "2023-05-01"
---

# Set up

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, out.width = '100%')
rm(list = ls())
```

```{r}
library(data.table)
library(stringi)
library(openxlsx)
library(RMySQL)
library(ggplot2)
library(tcplfit2)
library(tcpl)

print(sessionInfo())

```

# Load data

```{r}
load('DNTFalseNegatives/output/DNTFalseNegatives_dat4_2022-04-28.RData')
```

Prepare data

```{r}
dat4[, .N, by = .(acnm)]

usedat <- dat4[!is.na(acnm)]
usedat <- usedat[wllq == 1]
```

# Merge in tcpl info


```{r}
tcplConf(drv = 'MySQL', Sys.getenv('INVITRODB_USER_RO'), 
         Sys.getenv('INVITRODB_PASS_RO'), 
         Sys.getenv('INVITRODB_HOST_RO'), 
         'prod_internal_invitrodb_v3_5')
aeid.tb <- tcplLoadAeid(fld = 'asid', val = 20, add.fld = c('acid','acnm','aenm'))
mc5 <- tcplLoadData(lvl = 5L, fld = 'aeid', val = aeid.tb$aeid)
coff.tb <- merge(mc5[, unique(.SD), .SDcols = c('aeid','bmad','coff')],
                 aeid.tb, by = 'aeid', all = T)
coff.tb

# Get mc3 to calculate onesd
mc3 <- tcplLoadData(lvl = 3L, fld = 'aeid', val = aeid.tb$aeid)
onesd.tb <- mc3[, .(onesd = sd(resp[wllt == 'n'], na.rm = T)), by = .(aeid)]
coff.tb <- merge(coff.tb, onesd.tb, by = 'aeid')
```

Merge with usedat

```{r}
setdiff(usedat$acnm, coff.tb$acnm) # these ar ethe excluded endpoints, this is fine
coff.tb[, .N, by = .(acnm)][N > 1]

# I'm just going to stick with teh dn direciton
usedat <- merge(usedat, coff.tb[grepl('((_dn)|(LDH)|(AB))',aenm)], by = c('acnm'), all = F)
usedat[is.na(coff), .N]

usedat[, spid_acid := paste0(spid,'_',acid)]
```


# Normalize (calculate resp)

View endpoints

```{r}
usedat[, .N, by = .(acnm)]
```


```{r}
# Calculate bval
usedat[, conc := signif(conc, 3)]
usedat[, cndx := frank(conc, ties.method = 'dense'), by = .(spid, acid, apid)]
usedat[, bval := median(rval[wllt == 'n' | (wllt == 't' & cndx %in% c(1,2))], na.rm = T), by = .(acid, apid)]

# Calculate pval
usedat[grepl('_dn',aenm), pval := -100]
usedat[grepl('LDH',aenm), pval := median(rval[wllt == 'p'], na.rm = T), by = .(acid, apid)]
usedat[grepl("AB",aenm), pval := 0]

# Calculate resp.pc
usedat[, resp := (rval - bval)/(pval-bval)*100]

# multneg1?
# (want dn resp to correspond to a decrease, so yes)
usedat[grepl('_dn',aenm), resp := resp*-1] # including AB endpoint
```


# Run tcplfit2

```{r}
usedat <- usedat[order(spid, acid, conc)]

res <- data.table()
for(spid_acidi in unique(usedat$spid_acid)){
  # set up input data
  dati <- usedat[spid_acid == spid_acidi]
  row = list(conc=dati$conc,
             resp=dati$resp,
             bmed=0, # median of noise estimate (i.e., expected median of bval?)
             cutoff=unique(dati$coff),
             onesd=unique(dati$onesd),
             spid_acid = spid_acidi)
  
  out = concRespCore(row,
                     conthits=T,
                     bidirectional = T,
                     return.details = F,
                     do.plot=F)
  res <- rbind(res, out)
}

```

# View plots

```{r}

# Calculate ymin/max by acnm
usedat[, ymin := pmin(-1*coff, quantile(resp, 0.01, na.rm = T)), by = .(acid)]
usedat[, ymax := pmax(coff, quantile(resp, 0.99, na.rm = T)), by = .(acid)]

# add acnm, other id columns
res <- merge(res, usedat[, unique(.SD), .SDcols = c('spid_acid','spid','acid','acnm','ymin','ymax')], by = c('spid_acid'), all.x = T)

# add coloumns that conc resp plot is expecting
res[, name := spid]
res[, assay := acnm]

# Make plots
plot_name_base <- 'DNTFalseNegatives/figs/DNTFalseNegatives_tcplfit2_plots_2023-05-01'

for (spidi in unique(res$spid)) {
  pdf(file = paste0(plot_name_base, '_',spidi,'.pdf'),
      width = 10, height = 10)
  par(mfrow = c())
  res2 <- res[spid == spidi]
  for (i in 1:nrow(res2)) {
    concRespPlot(res2[i],
                 ymin = res2[i, ymin],
                 ymax = res2[i, ymax])
  }  
  graphics.off()
}

```

# Notes on interpreting plots/output

I'm pretty sure all conc's are in uM (not log10uM)

**Values**:

* mthd = fit_method (curve fit selected)
* top = top of fitted model. Either the top asymptote parameter (tp) is defined for that model, or the model value at the highest conc tested
* BMD = bench mark dose (i.e., concentration at BMR value = onesd*bmr_scale. The default bmr_scale is 1.349.). I assume this is in uM as well
* ACC = activity at cutoff (defined by coff). 


**Plot items**:

* gray region = +/- cutoff
* additional black horizontal lines (not at 0 and not at coff) = bench mark response value
* green region = bench mark dose lower bound, upper bound, and estimate with thick line (with exception handling for NAs). Min and max of green region just based on a fixed multiple of ymin and ymax

**Other notes**:

* conc range (x-axis) is hard-coded in `concRespCore` (-3 to 2 on log10 scale)

# Quick summary of results

```{r}
res[hitcall > 0.8, .(num_hitc_above_0.8 = .N), by = .(spid)]
#                      spid num_hitc_above_0.8
# 1: 5,5'-Diphenylhydantoin                  8
# 2:          6-PPD Quinone                  3
# 3:                  6-PPD                 10
# 4:               Caffeine                  3
# 5:          Dexamethasone                  6
# 6:                  Maneb                  4
```

